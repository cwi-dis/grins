//============================================================================
//
//  Microsoft Windows Media Technology
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:        wmsdkidl.idl
//
//  Description: 
//
//============================================================================

cpp_quote( "//=========================================================================" )
cpp_quote( "//" )
cpp_quote( "//  THIS SOFTWARE HAS BEEN LICENSED FROM MICROSOFT CORPORATION PURSUANT " )
cpp_quote( "//  TO THE TERMS OF AN END USER LICENSE AGREEMENT (\"EULA\").  " )
cpp_quote( "//  PLEASE REFER TO THE TEXT OF THE EULA TO DETERMINE THE RIGHTS TO USE THE SOFTWARE.  " )
cpp_quote( "//" )
cpp_quote( "// Copyright (C) Microsoft Corporation, 1999 - 1999  All Rights Reserved." )
cpp_quote( "//" )
cpp_quote( "//=========================================================================" )

///////////////////////////////////////////////////////////////////////////////
//
// Enumerations and constants used by the SDK.
//
///////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//
// Imports, typedefs and forward declarations
//
import "oaidl.idl";
import "wmsbuffer.idl";

typedef unsigned __int64 QWORD;

//
// Here's a list of all the interfaces we define in this file:
//
interface IWMMediaProps;
interface IWMVideoMediaProps;

interface IWMWriter;
interface IWMInputMediaProps;

interface IWMReader;
interface IWMOutputMediaProps;

interface IWMReaderCallback;

interface IWMMetadataEditor;

interface IWMHeaderInfo;

interface IWMProfile;
interface IWMProfileManager;
interface IWMStreamConfig;
interface IWMStreamList;
interface IWMMutualExclusion;

interface IWMWriterAdvanced;
interface IWMWriterSink;
interface IWMWriterFileSink;
interface IWMWriterNetworkSink;

interface IWMReaderAdvanced;
interface IWMReaderCallbackAdvanced;

///////////////////////////////////////////////////////////////////////////////
//
// Attributes
//
///////////////////////////////////////////////////////////////////////////////

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// These are the special case attributes that give information " )
cpp_quote( "// about the ASF file." )
cpp_quote( "//" )
cpp_quote( "static const DWORD g_dwWMSpecialAttributes = 7;" )
cpp_quote( "static const WCHAR *g_wszWMDuration = L\"Duration\";" )
cpp_quote( "static const WCHAR *g_wszWMBitrate = L\"Bitrate\";" )
cpp_quote( "static const WCHAR *g_wszWMSeekable = L\"Seekable\";" )
cpp_quote( "static const WCHAR *g_wszWMBroadcast = L\"Broadcast\";" )
cpp_quote( "static const WCHAR *g_wszWMProtected = L\"Is_Protected\";" )
cpp_quote( "static const WCHAR *g_wszWMTrusted = L\"Is_Trusted\";" )
cpp_quote( "static const WCHAR *g_wszWMSignature_Name = L\"Signature_Name\";" )
cpp_quote( "" )
cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// The content description object supports 5 basic attributes." )
cpp_quote( "//" )
cpp_quote( "static const DWORD g_dwWMContentAttributes = 5;" )
cpp_quote( "static const WCHAR *g_wszWMTitle = L\"Title\";" )
cpp_quote( "static const WCHAR *g_wszWMAuthor = L\"Author\";" )
cpp_quote( "static const WCHAR *g_wszWMDescription = L\"Description\";" )
cpp_quote( "static const WCHAR *g_wszWMRating = L\"Rating\";" )
cpp_quote( "static const WCHAR *g_wszWMCopyright = L\"Copyright\";" )
cpp_quote( "" )
cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// These attributes are used to set DRM properties on an ASF." )
cpp_quote( "//" )
cpp_quote( "static const WCHAR *g_wszWMUse_DRM = L\"Use_DRM\";" )
cpp_quote( "static const WCHAR *g_wszWMDRM_Flags = L\"DRM_Flags\";" )
cpp_quote( "static const WCHAR *g_wszWMDRM_Level = L\"DRM_Level\";" )
cpp_quote( "" )

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// These are the additional attributes defined in the ASF attribute" )
cpp_quote( "// namespace that gives information about the content in the ASF file." )
cpp_quote( "//" )
cpp_quote( "static const WCHAR *g_wszWMAlbumTitle = L\"WM/AlbumTitle\";" )
cpp_quote( "static const WCHAR *g_wszWMTrack = L\"WM/Track\";" )
cpp_quote( "static const WCHAR *g_wszWMPromotionURL = L\"WM/PromotionURL\";" )
cpp_quote( "static const WCHAR *g_wszWMAlbumCoverURL = L\"WM/AlbumCoverURL\";" )
cpp_quote( "static const WCHAR *g_wszWMGenre = L\"WM/Genre\";" )
cpp_quote( "static const WCHAR *g_wszWMYear = L\"WM/Year\";" )
cpp_quote( "" )


///////////////////////////////////////////////////////////////////////////////

cpp_quote( "////////////////////////////////////////////////////////////////" )
cpp_quote( "//" )
cpp_quote( "// Flags that can be passed into the Start method of IWMReader" )
cpp_quote( "//" )
cpp_quote( "#define WM_START_CURRENTPOSITION     ( ( QWORD )-1 )" )
cpp_quote( "" )

///////////////////////////////////////////////////////////////////////////////
//
// Enumerations and flags used by the SDK.
//
///////////////////////////////////////////////////////////////////////////////

//
// The flags that can be set on a sample (input or output).
//
enum 
{
    WM_SF_CLEANPOINT = 0x1,
    WM_SF_DISCONTINUITY = 0x2,
};

//
// Status messages that the reader and index objects can
// pass in the OnStatus call.
//
typedef enum WMT_STATUS
{
    WMT_ERROR             =  0,
    WMT_OPENED            =  1,
    WMT_BUFFERING_START   =  2,
    WMT_BUFFERING_STOP    =  3,
    WMT_EOF               =  4,
    WMT_END_OF_FILE       =  4,
    WMT_END_OF_SEGMENT    =  5,
    WMT_END_OF_STREAMING  =  6,
    WMT_LOCATING          =  7,
    WMT_CONNECTING        =  8,
    WMT_NO_RIGHTS         =  9,
    WMT_MISSING_CODEC     = 10,
    WMT_STARTED           = 11,
    WMT_STOPPED           = 12,
    WMT_CLOSED            = 13,
    WMT_STRIDING          = 14,
    WMT_TIMER             = 15,
    WMT_INDEX_PROGRESS    = 16,
} WMT_STATUS;

typedef enum WMT_RIGHTS
{
    WMT_RIGHT_PLAYBACK                  = 0x0001,
    WMT_RIGHT_COPY_TO_NON_SDMI_DEVICE   = 0x0002,
    WMT_RIGHT_COPY_TO_CD                = 0x0008,
    WMT_RIGHT_COPY_TO_SDMI_DEVICE       = 0x0010,
    WMT_RIGHT_ONE_TIME                  = 0x0020
} WMT_RIGHTS;


//
// Stream selection statuses (stati?).
//
typedef enum WMT_STREAM_SELECTION
{
    WMT_OFF               = 0,
    WMT_CLEANPOINT_ONLY   = 1,
    WMT_ON                = 2,
} WMT_STREAM_SELECTION;

//
// Attribute datatypes.
//
typedef enum WMT_ATTR_DATATYPE
{

    WMT_TYPE_DWORD		= 0,
    WMT_TYPE_STRING		= 1,
    WMT_TYPE_BINARY		= 2,
    WMT_TYPE_BOOL   	= 3,
    WMT_TYPE_QWORD      = 4,
    WMT_TYPE_WORD		= 5,
    WMT_TYPE_GUID		= 6,

} WMT_ATTR_DATATYPE;

//
// Windows Media versions.
//
typedef enum WMT_VERSION
{
    WMT_VER_4_0 = 0x00040000,
} WMT_VERSION;

//
// Protocols that the network sink supports.
//
typedef enum WMT_NET_PROTOCOL
{
    WMT_PROTOCOL_HTTP    = 0,
} WMT_NET_PROTOCOL;

///////////////////////////////////////////////////////////////////////////////
//
// Media-type structures and GUIDs.
//
///////////////////////////////////////////////////////////////////////////////

//
// Writer Statistics struct
//
typedef struct _WMWriterStatistics
{
    QWORD qwSampleCount;
    QWORD qwByteCount;

    QWORD qwDroppedSampleCount;
    QWORD qwDroppedByteCount;

    DWORD dwCurrentBitrate;
    DWORD dwAverageBitrate;
    DWORD dwExpectedBitrate;

    //
    // Sample rates are given as 1000 * (samples / second).
    //
    DWORD dwCurrentSampleRate;
    DWORD dwAverageSampleRate;
    DWORD dwExpectedSampleRate;
} WM_WRITER_STATISTICS;

//
// Reader Statistics struct
//
typedef struct _WMReaderStatistics
{
    DWORD cbSize;
    DWORD dwBandwidth;
    DWORD cPacketsReceived;
    DWORD cPacketsRecovered;
    DWORD cPacketsLost;
    WORD  wQuality;
} WM_READER_STATISTICS;

//
// Reader Client Info struct
//
typedef struct _WMReaderClientInfo
{
    DWORD cbSize;
    WCHAR *wszLang;              // 2-3 letter language code 
    WCHAR *wszBrowserUserAgent;  // Embedded browser's user-agent string
    WCHAR *wszBrowserWebPage;    // The web page that contains the plugin
    QWORD qwBrowserVersion;      // Something like 3.0.0.1234
    WCHAR *wszHostUniquePID;     // Unique player ID
    WCHAR *wszHostExe;           // iexplore.exe, netscape.exe dshow.exe, etc
    QWORD qwHostVersion;         // 4.70.12.15
} WM_READER_CLIENTINFO;

//
// We use DirectShow media types in this SDK. However, to avoid conflict with
// their names, we define our own version of the structure. This is exactly
// the same as an AM_MEDIA_TYPE!
//
typedef struct _WMMediaType
{
    GUID majortype;
    GUID subtype;
    BOOL bFixedSizeSamples;
    BOOL bTemporalCompression;
    ULONG lSampleSize;
    GUID formattype;
    IUnknown *pUnk;
    ULONG cbFormat;
    [size_is(cbFormat)] BYTE *pbFormat;
} WM_MEDIA_TYPE;


//
// This special GUID is used to create a subtype from an audio format tag, or
// video four-character code. Just fill in the first DWORD of the GUID with
// the appropriate value.
//
cpp_quote( "// 00000000-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_Base " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_Base, " )
cpp_quote( "0x00000000, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 73646976-0000-0010-8000-00AA00389B71  'vids' == WMMEDIATYPE_Video " )
cpp_quote( "EXTERN_GUID(WMMEDIATYPE_Video, " )
cpp_quote( "0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// e436eb78-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB1 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB1, " )
cpp_quote( "0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb79-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB4 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB4, " )
cpp_quote( "0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb7a-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB8 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB8, " )
cpp_quote( "0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb7b-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB565 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB565, " )
cpp_quote( "0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb7c-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB555 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB555, " )
cpp_quote( "0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb7d-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB24 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB24, " )
cpp_quote( "0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// e436eb7e-524f-11ce-9f53-0020af0ba770            MEDIASUBTYPE_RGB32 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_RGB32, " )
cpp_quote( "0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70); " )

cpp_quote( "// 30323449-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_I420 " )
cpp_quote( "DEFINE_GUID(WMMEDIASUBTYPE_I420, " )
cpp_quote( "0x30323449, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 56555949-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_IYUV " )
cpp_quote( "DEFINE_GUID(WMMEDIASUBTYPE_IYUV, " )
cpp_quote( "0x56555949, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 31313259-0000-0010-8000-00AA00389B71  'YV12' ==  MEDIASUBTYPE_YV12 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_YV12, " )
cpp_quote( "0x32315659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 32595559-0000-0010-8000-00AA00389B71  'YUY2' == MEDIASUBTYPE_YUY2 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_YUY2, " )
cpp_quote( "0x32595559, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 59565955-0000-0010-8000-00AA00389B71  'UYVY' ==  MEDIASUBTYPE_UYVY " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_UYVY, " )
cpp_quote( "0x59565955, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 55595659-0000-0010-8000-00AA00389B71  'YVYU' == MEDIASUBTYPE_YVYU " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_YVYU, " )
cpp_quote( "0x55595659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 39555659-0000-0010-8000-00AA00389B71  'YVU9' == MEDIASUBTYPE_YVU9 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_YVU9, " )
cpp_quote( "0x39555659, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 3334504D-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_MP43 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_MP43, " )
cpp_quote( "0x3334504D, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 73647561-0000-0010-8000-00AA00389B71  'auds' == WMMEDIATYPE_Audio " )
cpp_quote( "EXTERN_GUID(WMMEDIATYPE_Audio, " )
cpp_quote( "0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 00000001-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_PCM " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_PCM, " )
cpp_quote( "0x00000001, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 00000161-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_WMAudioV2 " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_WMAudioV2, " )
cpp_quote( "0x00000161, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 00000130-0000-0010-8000-00AA00389B71            WMMEDIASUBTYPE_ACELPnet " )
cpp_quote( "EXTERN_GUID(WMMEDIASUBTYPE_ACELPnet, " )
cpp_quote( "0x00000130, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71); " )

cpp_quote( "// 73636d64-0000-0010-8000-00AA00389B71  'scmd' == MEDIATYPE_Script " )
cpp_quote( "EXTERN_GUID(WMMEDIATYPE_Script, " )
cpp_quote( "0x73636d64, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); " )

cpp_quote( "// 05589f80-c356-11ce-bf01-00aa0055595a        WMFORMAT_VideoInfo " )
cpp_quote( "EXTERN_GUID(WMFORMAT_VideoInfo, " )
cpp_quote( "0x05589f80, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); " )

cpp_quote( "// 05589f81-c356-11ce-bf01-00aa0055595a        WMFORMAT_WaveFormatEx " )
cpp_quote( "EXTERN_GUID(WMFORMAT_WaveFormatEx, " )
cpp_quote( "0x05589f81, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a); " )

cpp_quote( "// 5C8510F2-DEBE-4ca7-BBA5-F07A104F8DFF        WMFORMAT_Script " )
cpp_quote( "EXTERN_GUID(WMFORMAT_Script, " )
cpp_quote( "0x5c8510f2, 0xdebe, 0x4ca7, 0xbb, 0xa5, 0xf0, 0x7a, 0x10, 0x4f, 0x8d, 0xff); " )

cpp_quote( "typedef struct tagWMVIDEOINFOHEADER" )
cpp_quote( "{" )
cpp_quote( "    //" )
cpp_quote( "    // The bit we really want to use." )
cpp_quote( "    //" )
cpp_quote( "    RECT rcSource;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Where the video should go." )
cpp_quote( "    //" )
cpp_quote( "    RECT rcTarget;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Approximate bit data rate." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwBitRate;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Bit error rate for this stream." )
cpp_quote( "    //" )
cpp_quote( "    DWORD dwBitErrorRate;" )
cpp_quote( "" )
cpp_quote( "    //" )
cpp_quote( "    // Average time per frame (100ns units)." )
cpp_quote( "    //" )
cpp_quote( "    LONGLONG AvgTimePerFrame;" )
cpp_quote( "" )
cpp_quote( "    BITMAPINFOHEADER bmiHeader;" )
cpp_quote( "} WMVIDEOINFOHEADER;" )

cpp_quote( "typedef struct tagWMSCRIPTFORMAT" )
cpp_quote( "{" )
cpp_quote( "    GUID    scriptType; ")
cpp_quote( "} WMSCRIPTFORMAT;" )

cpp_quote( "// 82f38a70-c29f-11d1-97ad-00a0c95ea850        WMSCRIPTTYPE_TwoStrings " )
cpp_quote( "EXTERN_GUID( WMSCRIPTTYPE_TwoStrings, " )
cpp_quote( "0x82f38a70,0xc29f,0x11d1,0x97,0xad,0x00,0xa0,0xc9,0x5e,0xa8,0x50); " )

///////////////////////////////////////////////////////////////////////////////
//
// IID GUIDs defined here.
//
///////////////////////////////////////////////////////////////////////////////

cpp_quote( "EXTERN_GUID( IID_IWMMediaProps,         0x96406bce,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMVideoMediaProps,    0x96406bcf,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriter,             0x96406bd4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMInputMediaProps,    0x96406bd5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMReader,            0x96406bd6,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMOutputMediaProps,   0x96406bd7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMStatusCallback,     0x6d7cdc70,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderCallback,     0x96406bd8,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMMetadataEditor,     0x96406bd9,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMHeaderInfo,         0x96406bda,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMProfileManager,     0xd16679f2,0x6ca0,0x472d,0x8d,0x31,0x2f,0x5d,0x55,0xae,0xe1,0x55 );" )
cpp_quote( "EXTERN_GUID( IID_IWMProfile,            0x96406bdb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMStreamConfig,       0x96406bdc,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMStreamList,         0x96406bdd,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMMutualExclusion,    0x96406bde,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterAdvanced,     0x96406be3,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterSink,         0x96406be4,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterFileSink,     0x96406be5,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMWriterNetworkSink,  0x96406be7,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderAdvanced,     0x96406bea,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderCallbackAdvanced, 0x96406beb,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMReaderStreamClock,  0x96406bed,0x2b2b,0x11d3,0xb3,0x6b,0x00,0xc0,0x4f,0x61,0x08,0xff );" )
cpp_quote( "EXTERN_GUID( IID_IWMIndexer,            0x6d7cdc71,0x9888,0x11d3,0x8e,0xdc,0x00,0xc0,0x4f,0x61,0x09,0xcf );" )


///////////////////////////////////////////////////////////////////////////////
//
// Other GUIDs defined here
//
///////////////////////////////////////////////////////////////////////////////

cpp_quote( "EXTERN_GUID( CLSID_WMMUTEX_Bitrate, 0xD6E22A01,0x35DA,0x11D1,0x90,0x34,0x00,0xA0,0xC9,0x03,0x49,0xBE );" )


///////////////////////////////////////////////////////////////////////////////
//
// Creation functions.
//
// The SDK supports 3 major objects:
// - CLSID_WMWriter - For writing out WM content.
// - CLSID_WMReader - For playing back WM content.
// - CLSID_WMMetadataEditor - For getting and editing header metadata in WM
//   content.
//
///////////////////////////////////////////////////////////////////////////////

cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateWriter( IUnknown* pUnkReserved, IWMWriter **ppWriter );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateReader( IUnknown* pUnkReserved, DWORD dwRights, IWMReader **ppReader );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateEditor( IWMMetadataEditor **ppEditor );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateIndexer( IWMIndexer **ppIndexer );" )

cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateProfileManager( IWMProfileManager **ppProfileManager );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateWriterFileSink( IWMWriterFileSink **ppSink );" )
cpp_quote( "HRESULT STDMETHODCALLTYPE WMCreateWriterNetworkSink( IWMWriterNetworkSink **ppSink );" )

///////////////////////////////////////////////////////////////////////////////
//
// The following interfaces define the media types that this SDK supports.
// These media types are used by the writer, the reader, and the profile
// object, to identify the media-type specific properties of a media stream.
//
// The main media type is stored in the WM_MEDIA_TYPE structure. Some
// interesting (option) parameters may exist for particular stream types;
// in that case, an IWM<x>MediaProps interface can be used to get and set
// these additional parameters.
//


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BCE-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMMediaProps Interface"),
    pointer_default(unique),
    local
]
interface IWMMediaProps : IUnknown
{
    //
    // GetType is provided for convenience; it returns the same as the
    // majortype of the WM_MEDIA_TYPE.
    //
    HRESULT GetType( [out] GUID *pguidType );

    HRESULT GetMediaType( [out] WM_MEDIA_TYPE *pType,
                          [in, out] DWORD *pcbType );
    HRESULT SetMediaType( [in] WM_MEDIA_TYPE *pType );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BCF-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMVideoMediaProps Interface"),
    pointer_default(unique),
    local
]
interface IWMVideoMediaProps : IWMMediaProps
{
    HRESULT GetMaxKeyFrameSpacing( [out] LONGLONG *pllTime );
    HRESULT SetMaxKeyFrameSpacing( [in] LONGLONG llTime );

    HRESULT GetQuality( [out] DWORD *pdwQuality );
    HRESULT SetQuality( [in] DWORD dwQuality );
};


///////////////////////////////////////////////////////////////////////////////
//
// The CLSID_WMWriter basic interfaces.
//
// Usage scenario is as follows:
// 1) SetProfile to define the configuration.
// 2) Set the outputs.
// 3) Call GetInputCount (which is valid after (1)), and GetInputProps for
//    each stream. Get the default input format, and change it if desired.
// 3.5) Call SetAttribute to add metadata to the header
// At this point, the writer has been configured.
// 4) Call WriteSample repeatedly, until done. (Note that the AllocateSample
//    call is just provided for convenience. You are welcome to pass in your
//    own samples.)
// 5) Call Flush to write out any buffered data, and update the header and
//    index.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD4-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMWriter Interface"),
    pointer_default(unique),
    local
]
interface IWMWriter : IUnknown
{
    // This interface QI's for IWMHeaderInfo, and IWMWriterAdvanced.

    //
    // There are 3 options for setting the profile on the writer. Note that
    // setting the profile means that the profile is copied into the writer.
    // Further editing of that profile object will have no effect, unless
    // SetProfile() is called again.
    //
    // Calling SetProfile() removes any previously set header attribute info
    //
    HRESULT SetProfileByID( [in] REFGUID guidProfile );
    HRESULT SetProfile( [in] IWMProfile *pProfile );

    //
    // The easiest way to use the writer is just to write to file.
    //
    HRESULT SetOutputFilename( [in] const WCHAR *pwszFilename );

    //
    // The user can enumerate through the various inputs, and get the input
    // format. Note that these are not ASF streams; one input stream may map
    // to multiple ASF streams in a MEB scenario.
    //
    // Manipulating the IWMInputMediaProps has no effect on the writer, unless
    // the user calls SetInputProps to configure the input.
    //
    HRESULT GetInputCount( [out] DWORD *pcInputs );
    HRESULT GetInputProps( [in] DWORD dwInputNum,
                           [out] IWMInputMediaProps **ppInput );
    HRESULT SetInputProps( [in] DWORD dwInputNum,
                           [in] IWMInputMediaProps *pInput );

    //
    // Used for determining all possible format types supported by this
    // input on the writer. 
    //
    HRESULT GetInputFormatCount(    [in] DWORD dwInputNumber,
                                    [out] DWORD *pcFormats );

    HRESULT GetInputFormat( [in] DWORD dwInputNumber,
                            [in] DWORD dwFormatNumber,
                            [out] IWMInputMediaProps** pProps );

    //
    // You must call BeginWriting before sending any samples, and
    // you must call EndWriting when you're done sending samples.
    //
    HRESULT BeginWriting();

    //
    // EndWriting flushes everything, updates indices and headers,
    // and closes the file.
    //
    HRESULT EndWriting();

    //
    // Allocate a sample. This is optional; the user is welcome to allocate
    // their own buffer class.
    //
    HRESULT AllocateSample( [in] DWORD dwSampleSize,
                            [out] INSSBuffer **ppSample );

    HRESULT WriteSample( [in] DWORD dwInputNum,
                         [in] QWORD cnsSampleTime,
                         [in] DWORD dwFlags,
                         [in] INSSBuffer *pSample );

    //
    // Flush() will flush the writer, but leaves the writer prepared to run
    // again, when WriteSample() is called again.
    // Flush() also causes an updated header to be sent to the sink.
    //
    HRESULT Flush();

};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD5-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMInputMediaProps Interface"),
    pointer_default(unique),
    local
]
interface IWMInputMediaProps : IWMMediaProps
{
    HRESULT GetConnectionName( [out] WCHAR *pwszName,
                               [in, out] WORD *pcchName );
    HRESULT GetGroupName( [out] WCHAR *pwszName,
                          [in, out] WORD *pcchName );
};


///////////////////////////////////////////////////////////////////////////////
//
// The CLSID_WMReader basic interfaces.
//
// Usage is as follows:
// 1) Call Open with a URL (possibly a local filename) and a user-supplied
//    callback. After open has completed, the file has been opened and parsed.
// 2) Call GetOutputCount, and GetOutputProps for each output. This
//    is valid after (1). This allows the user to get the output format for
//    each output.
// 3) Call Start. Status messages and samples will begin arriving in the
//    callback function.
// 4) Continue with any combination of Start/Stop/Pause/Seek/SetRate, until
//    finished.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD6-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMReader Interface"),
    pointer_default(unique),
    local
]
interface IWMReader : IUnknown
{
    // This interface QI's for IWMHeaderInfo, IWMProfile and IWMReaderAdvanced.

    //
    // Open is an asynch call; it returns almost immediately (if the URL
    // is valid), and the user should wait for appropriate OnStatus calls to
    // be sent to the callback.
    //
    HRESULT Open( [in] const WCHAR *pwszURL,
                  [in] IWMReaderCallback *pCallback,
                  [in] void *pvContext );
    HRESULT Close();

    //
    // The user can enumerate through the various outputs, and get the
    // output format for that data.
    //
    // Manipulating the IWMOutputMediaProps has no effect on the output, unless
    // the user also calls SetOutputProps.
    //
    HRESULT GetOutputCount( [out] DWORD *pcOutputs );
    HRESULT GetOutputProps( [in] DWORD dwOutputNum,
                            [out] IWMOutputMediaProps **ppOutput );
    HRESULT SetOutputProps( [in] DWORD dwOutputNum,
                            [in] IWMOutputMediaProps *pOutput );

    //
    // Used for determining all possible format types supported by this
    // output on the reader. 
    //
    HRESULT GetOutputFormatCount(   [in] DWORD dwOutputNumber,
                                    [out] DWORD *pcFormats );

    HRESULT GetOutputFormat( [in] DWORD dwOutputNumber,
                             [in] DWORD dwFormatNumber,
                             [out] IWMOutputMediaProps** ppProps );
                             
    //
    // If duration is 0, play to the end of the file.
    // If msStart is set to WM_START_CURRENTPOSITION then don't perform a seek
    // operation.  A good use for this is when you want to change the rate but
    // not the current file position.  
    //
    // Note that any call to start while Paused will be treated as a seek.
    // Even calls to Start( WM_START_CURRENTPOSITION, ... ).  If your intention
    // is to seek (which will incur the buffering penalty from network files)
    // then you can go ahead and call Start.  However, if your intention was
    // to continue playing from where the user paused, you should call Resume
    // instead.
    //
    HRESULT Start( [in] QWORD cnsStart, 
                   [in] QWORD cnsDuration, 
                   [in] float fRate, 
                   [in] void *pvContext );
    HRESULT Stop();
    HRESULT Pause();
    HRESULT Resume();
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD7-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMOutputMediaProps Interface"),
    pointer_default(unique),
    local
]
interface IWMOutputMediaProps : IWMMediaProps
{
    //
    // A Stream Group and type together uniquely identify each output. (The
    // type is on IWMMediaProps).
    //
    HRESULT GetStreamGroupName( [out] WCHAR *pwszName,
                                [in, out] WORD *pcchName );
    HRESULT GetConnectionName( [out] WCHAR *pwszName,
                               [in, out] WORD *pcchName );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 6d7cdc70-9888-11d3-8edc-00c04f6109cf ),
    helpstring( "IWMStatusCallback Interface"),
    pointer_default(unique),
    local
]
interface IWMStatusCallback : IUnknown
{
    //
    // The contents pParam depends on the Status.
    //
    HRESULT OnStatus( [in] WMT_STATUS Status, 
                      [in] HRESULT hr,
                      [in] WMT_ATTR_DATATYPE dwType,
                      [in] BYTE *pValue,
                      [in] void *pvContext );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD8-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMReaderCallback Interface"),
    pointer_default(unique),
    local
]
interface IWMReaderCallback : IWMStatusCallback
{
    //
    // dwSampleDuration will be 0 for most media types.
    //
    HRESULT OnSample( [in] DWORD dwOutputNum,
                      [in] QWORD cnsSampleTime,
                      [in] QWORD cnsSampleDuration,
                      [in] DWORD dwFlags,
                      [in] INSSBuffer *pSample,
                      [in] void *pvContext );
};


///////////////////////////////////////////////////////////////////////////////
//
// The CLSID_WMMetadataEditor basic interfaces.
//
// Usage:
// 1) Call Open with a filename.
// 2) QI for IWMHeaderInfo, and use that to get and set attributes as
//    needed.
// 3) Flush() will cause any changes to be written back to disk (if possible).
// 4) Close() closes the file without writing any changes to disk.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BD9-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMMetadataEditor Interface"),
    pointer_default(unique),
    local
]
interface IWMMetadataEditor : IUnknown
{
    // QI this for IWMHeaderInfo to edit the header attributes.

    //
    // Manage the file
    //
    HRESULT Open( [in] const WCHAR *pwszFilename );
    HRESULT Close();
    HRESULT Flush();
};


///////////////////////////////////////////////////////////////////////////////
//
// Below are utility interfaces used across all 3 of the main objects.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BDA-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMHeaderInfo Interface"),
    pointer_default(unique),
    local
]
//
// The 3 main interface (IWMWriter, IWMReader, and 
// IWMMetadataEditor) can be QI'd for this interface to get and set
// header attributes, and markers.
//
interface IWMHeaderInfo : IUnknown
{
    //
    // For attributes, the stream number passed in means:
    // -1 (0xffff) to specifies "any or no stream".
    // 0 specifies "no stream".
    // Any other value indicates the stream number.
    //
    // Windows Media version 4 and earlier does not support per stream
    // attributes, so any stream number other than 0 will fail.
    //
    HRESULT GetAttributeCount( [in] WORD wStreamNum,
                               [out] WORD *pcAttributes );
    HRESULT GetAttributeByIndex( [in] WORD wIndex,
                                 [in, out] WORD *pwStreamNum,
                                 [out] WCHAR *pwszName,
                                 [in,out] WORD *pcchNameLen,
                                 [out] WMT_ATTR_DATATYPE *pType,
                                 [out] BYTE *pValue,
                                 [in,out] WORD *pcbLength );
    HRESULT GetAttributeByName( [in, out] WORD *pwStreamNum,
                                [in] LPCWSTR pszName,
                                [out] WMT_ATTR_DATATYPE *pType,
                                [out] BYTE *pValue,
                                [in,out] WORD *pcbLength );
    HRESULT SetAttribute( [in] WORD wStreamNum,
                          [in] LPCWSTR pszName,
                          [in] WMT_ATTR_DATATYPE Type,
                          [in] const BYTE *pValue,
                          [in] WORD cbLength );

    //
    // Marker methods.
    //
    HRESULT GetMarkerCount( [out] WORD *pcMarkers );
    HRESULT GetMarker( [in] WORD wIndex,
                       [out] WCHAR *pwszMarkerName,
                       [in, out] WORD *pcchMarkerNameLen,
                       [out] QWORD *pcnsMarkerTime );
    HRESULT AddMarker( [in] WCHAR *pwszMarkerName,
                       [in] QWORD cnsMarkerTime );
    HRESULT RemoveMarker( [in] WORD wIndex );

    //
    // Script command methods.
    //
    HRESULT GetScriptCount( [out] WORD *pcScripts );
    HRESULT GetScript( [in] WORD wIndex,
                       [out] WCHAR *pwszType,
                       [in, out] WORD *pcchTypeLen,
                       [out] WCHAR *pwszCommand,
                       [in, out] WORD *pcchCommandLen,
                       [out] QWORD *pcnsScriptTime );
    HRESULT AddScript( [in] WCHAR *pwszType,
                       [in] WCHAR *pwszCommand,
                       [in] QWORD cnsScriptTime );
    HRESULT RemoveScript( [in] WORD wIndex );
};


///////////////////////////////////////////////////////////////////////////////
//
// The profile API. The intention is that most users don't touch the profile
// API, but just use pre-existing profiles.
//
// Profiles define authoring configurations, such as stream types, bitrates,
// etc.
//
///////////////////////////////////////////////////////////////////////////////


[
    object,
    uuid( d16679f2-6ca0-472d-8d31-2f5d55aee155 ),
    helpstring( "IWMProfileManager Interface"),
    pointer_default(unique),
    local
]
interface IWMProfileManager : IUnknown
{
    //
    // Create a profile with nothing in it.
    //
    HRESULT CreateEmptyProfile( [in] WMT_VERSION dwVersion,
                                [out] IWMProfile **ppProfile );

    //
    // Load a system profile given its ID.
    //
    HRESULT LoadProfileByID( [in] REFGUID guidProfile,
                               [out] IWMProfile **ppProfile );

    //
    // Load a profile from a stored string.
    //
    HRESULT LoadProfileByData( [in] const WCHAR *pwszProfile,
                               [out] IWMProfile **ppProfile );

    //
    // Save profile specified by its string.
    //
    HRESULT SaveProfile( [in] IWMProfile *pIWMProfile, [in] WCHAR *pwszProfile, [in, out] DWORD *pdwLength );

    //
    // Iterate through the system profiles.
    //
    HRESULT GetSystemProfileCount( [out] DWORD *pcProfiles );
    HRESULT LoadSystemProfile( [in] DWORD dwProfileIndex,
                               [out] IWMProfile **ppProfile );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BDB-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMProfile Interface"),
    pointer_default(unique),
    local
]
interface IWMProfile : IUnknown
{
    //
    // By default, when the user creates a profile, it will use the latest
    // version of Windows Media. To create a backward-compatible profile,
    // the user should reset the profile (which removes all information
    // currently in the profile) with the appropriate version.
    //
    HRESULT GetVersion( [out] WMT_VERSION *pdwVersion );

    //
    // Profiles have names and descriptions, for use when displaying lists
    // of profiles, etc.
    //
    HRESULT GetName( [out] WCHAR *pwszName,
                     [in, out] DWORD *pcchName );
    HRESULT SetName( [in] const WCHAR *pwszName );
    HRESULT GetDescription( [out] WCHAR *pwszDescription,
                            [in, out] DWORD *pcchName );
    HRESULT SetDescription( [in] const WCHAR *pwszDescription );

    //
    // Methods for enumerating the streams. Note that updating the
    // returned IWMStreamConfig has no effect on the profile until you
    // call ReconfigStream().
    //
    HRESULT GetStreamCount( [out] DWORD *pcStreams );
    HRESULT GetStream( [in] DWORD dwStreamIndex,
                       [out] IWMStreamConfig **ppConfig );
    HRESULT GetStreamByNumber( [in] WORD wStreamNum,
                               [out] IWMStreamConfig **ppConfig );
    //
    // Remove a stream.
    //
    HRESULT RemoveStream( [in] IWMStreamConfig *pConfig );
    HRESULT RemoveStreamByNumber( [in] WORD wStreamNum );

    //
    // Adding a stream copies the config into the profile. 
    //
    HRESULT AddStream( [in] IWMStreamConfig *pConfig );
    HRESULT ReconfigStream( [in] IWMStreamConfig *pConfig );

    //
    // Create a new stream config object (avoiding the need to CoCreate).
    // This will still need to be added to the profile using the AddStream()
    // call (but only after it has been configured).
    //
    HRESULT CreateNewStream( [in] REFGUID guidStreamType,
                             [out] IWMStreamConfig **ppConfig );

    //
    // Mutual Exclusion. As above, only Add and Remove actual change the
    // profile.
    //
    HRESULT GetMutualExclusionCount( [out] DWORD *pcME );
    HRESULT GetMutualExclusion( [in] DWORD dwMEIndex,
                                [out] IWMMutualExclusion **ppME );
    HRESULT RemoveMutualExclusion( [in] IWMMutualExclusion *pME );
    HRESULT AddMutualExclusion( [in] IWMMutualExclusion *pME );
    HRESULT CreateNewMutualExclusion( [out] IWMMutualExclusion **ppME );

};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BDC-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMStreamConfig Interface"),
    pointer_default(unique),
    local
]
//
// IWMStreamConfig represents an ASF stream.
//
interface IWMStreamConfig : IUnknown
{
    // This interface QI's for IWMMediaProps and one of it's inheritors.
    // (IWMVideoMediaProps, for instance). 

    HRESULT GetStreamType( [out] GUID *pguidStreamType );

    HRESULT GetStreamNumber( [out] WORD *pwStreamNum );
    HRESULT SetStreamNumber( [in] WORD wStreamNum );

    HRESULT GetStreamName( [out] WCHAR *pwszStreamName,
                           [in, out] WORD *pcchStreamName );
    HRESULT SetStreamName( [in] WCHAR *pwszStreamName );

    HRESULT GetConnectionName( [out] WCHAR *pwszInputName,
                               [in, out] WORD *pcchInputName );
    HRESULT SetConnectionName( [in] WCHAR *pwszInputName );

    HRESULT GetBitrate( [out] DWORD *pdwBitrate );
    HRESULT SetBitrate( [in] DWORD pdwBitrate );

    //
    // A buffer window of -1 (0xffffffff) indicates that the buffer window
    // is unknown. On the writer side, this means the writer can use whatever
    // buffer window it chooses.
    //
    HRESULT GetBufferWindow( [out] DWORD *pmsBufferWindow );
    HRESULT SetBufferWindow( [in] DWORD msBufferWindow );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BDD-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMStreamList Interface"),
    pointer_default(unique),
    local
]
//
// IWMStreamList is used for the various objects that define relationships
// between streams.
//
interface IWMStreamList : IUnknown
{
    HRESULT GetStreams( [out] WORD *pwStreamNumArray,
                        [in, out] WORD *pcStreams );

    HRESULT AddStream( [in] WORD wStreamNum );
    HRESULT RemoveStream( [in] WORD wStreamNum );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BDE-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMMutualExclusion Interface"),
    pointer_default(unique),
    local
]
//
// IWMMutualExclusion specifies a group of streams, of which only one can
// be played at once. These are used to do MEB (stream selection based on
// bandwidth).
//
interface IWMMutualExclusion : IWMStreamList
{
    //
    // The possible types of mutual exclusion are defined in the ASF
    // header.
    //
    HRESULT GetType( [out] GUID *pguidType );
    HRESULT SetType( [in] REFGUID guidType );
};



///////////////////////////////////////////////////////////////////////////////
//
// Advanced features.
//
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BE3-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMWriterAdvanced Interface"),
    pointer_default(unique),
    local
]
//
// The writer can be QI'd for this interface, which provides advanced writing
// functionality.
//
interface IWMWriterAdvanced : IUnknown
{
    //
    // Sinks are where the output ASF data goes.
    //
    HRESULT GetSinkCount( [out] DWORD *pcSinks );
    HRESULT GetSink( [in] DWORD dwSinkNum,
                     [out] IWMWriterSink **ppSink );
    HRESULT AddSink( [in] IWMWriterSink *pSink );
    HRESULT RemoveSink( [in] IWMWriterSink *pSink );

    //
    // By default, the user provides samples to an input on the
    // IWMWriter interface, and the samples may be compressed, put
    // into a MEB stream, etc. However, the user can use this interface to
    // put the samples directly into the ASF, with no compression etc.
    //
    HRESULT WriteStreamSample( [in] WORD wStreamNum,
                               [in] QWORD cnsSampleTime,
                               [in] DWORD msSampleSendTime,
                               [in] QWORD cnsSampleDuration,
                               [in] DWORD dwFlags,
                               [in] INSSBuffer *pSample );

    //
    // The writer may be running in real-time. If so, it's interesting to
    // get the current time from the writer.
    //
    HRESULT SetLiveSource( BOOL fIsLiveSource );
    HRESULT IsRealTime( [out] BOOL *pfRealTime );
    HRESULT GetWriterTime( [out] QWORD *pcnsCurrentTime );

    //
    // To get statistics, pass in a WM_WRITER_STATISTICS structure, which
    // will be filled out by the GetStatistics() call with the requested
    // stats.
    //
    // Pass in a stream number to get statistics for a specific stream, or
    // pass 0 to get statistics for the entire ASF file.
    //
    HRESULT GetStatistics( [in] WORD wStreamNum,
                           [out] WM_WRITER_STATISTICS *pStats );

    //
    // Sync tolerance determines how far out of sync the inputs will be allowed
    // to get before samples are thrown away.  Default is 3000 ms.
    //
    HRESULT SetSyncTolerance(   [in]    DWORD   msWindow );
    HRESULT GetSyncTolerance(   [out]   DWORD*  pmsWindow );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BE4-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMWriterSink Interface"),
    pointer_default(unique),
    local
]
//
// This is the interface that receives raw ASF from the writer.
//
interface IWMWriterSink : IUnknown
{
    HRESULT OnHeader( [in] INSSBuffer *pHeader );

    //
    // Some sinks require that data be fed to them in real-time.
    //
    HRESULT IsRealTime( [out] BOOL *pfRealTime );

    HRESULT AllocateDataUnit( [in] DWORD cbDataUnit,
                              [out] INSSBuffer **ppDataUnit );
    HRESULT OnDataUnit( [in] INSSBuffer *pDataUnit );

    //
    // This function is called when the writer is done sending data.
    // 
    HRESULT OnEndWriting();
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BE5-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMWriterFileSink Interface"),
    pointer_default(unique),
    local
]
interface IWMWriterFileSink : IWMWriterSink
{
    HRESULT Open( [in] const WCHAR *pwszFilename );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BE7-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMWriterNetworkSink Interface"),
    pointer_default(unique),
    local
]
interface IWMWriterNetworkSink : IWMWriterSink
{
    //
    // Determine the maximum number of clients that can connect to this sink.
    // Default is 10.
    //
    HRESULT SetMaximumClients( [in] DWORD dwMaxClients );
    HRESULT GetMaximumClients( [out] DWORD *pdwMaxClients );

    //
    // The network protocol that the network sink will use.
    //
    HRESULT SetNetworkProtocol( [in] WMT_NET_PROTOCOL protocol );
    HRESULT GetNetworkProtocol( [out] WMT_NET_PROTOCOL *pProtocol );

    //
    // Find out the name of the URL on which we're broadcasting
    //
    HRESULT GetHostURL( [out] WCHAR *pwszURL,
                        [in, out] DWORD *pcchURL );

    //
    // The method claims the network port number. Close the sink to release
    // the port.
    //
    // Specify 0 for the port number and the sink will select a port for
    // the user.
    //
    HRESULT Open( [in, out] DWORD *pdwPortNum );

    //
    // Disconnect all connected clients.
    //
    HRESULT Disconnect();

    //
    // Close and release the open port.
    //
    HRESULT Close();
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BEA-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMReaderAdvanced Interface"),
    pointer_default(unique),
    local
]
//
// The reader can be QI'd for this interface for advanced functionality.
//
interface IWMReaderAdvanced : IUnknown
{
    //
    // The user may want to drive the clock himself, particularly if he wants
    // to source from a file faster-than-realtime. This call may fail if the
    // current source does not support user-driven clocks.
    //
    // The proper way for a user to drive the clock is for the user to call
    // DeliverTime, and then wait for the OnTime call on 
    // IWMReaderCallbackAdvanced to reach the time he specified.
    //
    HRESULT SetUserProvidedClock( [in] BOOL fUserClock );
    HRESULT GetUserProvidedClock( [out] BOOL *pfUserClock );
    HRESULT DeliverTime( [in] QWORD cnsTime );

    //
    // The user can select streams manually, instead of relying on the
    // automatic bandwidth stream selection that the reader will
    // normally do. To figure out what streams are in this ASF and what their
    // numbers are, QI for IWMProfile.
    //
    // When SetManualStreamSelection( TRUE ) is called, all streams are
    // selected by default.
    //
    HRESULT SetManualStreamSelection( [in] BOOL fSelection );
    HRESULT GetManualStreamSelection( [out] BOOL *pfSelection );
    HRESULT SetStreamsSelected( [in] WORD cStreamCount,
                                [in] WORD *pwStreamNumbers,
                                [in] WMT_STREAM_SELECTION *pSelections );
    HRESULT GetStreamSelected( [in] WORD wStreamNum,
                               [out] WMT_STREAM_SELECTION *pSelection );

    //
    // The user can also choose to get callbacks when automatic stream
    // selection occurs.
    //
    HRESULT SetReceiveSelectionCallbacks( [in] BOOL fGetCallbacks );
    HRESULT GetReceiveSelectionCallbacks( [in] BOOL *pfGetCallbacks );

    //
    // The user can register himself to receive samples directly from the
    // ASF streams, rather than letting the Reader decompress them. Note that
    // to do this, the IWMReaderCallback (supplied by the user) must support
    // IWMReaderCallbackAdvanced.
    //
    // To get actual information about the contents of a stream, QI the
    // object for IWMProfile.
    //
    HRESULT SetReceiveStreamSamples( [in] WORD wStreamNum,
                                     [in] BOOL fReceiveStreamSamples );
    HRESULT GetReceiveStreamSamples( [in] WORD wStreamNum,
                                     [out] BOOL *pfReceiveStreamSamples );

    //
    // The user can register himself to provide buffers for any of the outputs
    // (for instance, DDraw buffers). The actual allocation is on the
    // IWMReaderCallbackAdvanced interface.
    //
    HRESULT SetAllocateForOutput( [in] DWORD dwOutputNum,
                                  [in] BOOL fAllocate );
    HRESULT GetAllocateForOutput( [in] DWORD dwOutputNum,
                                  [out] BOOL *pfAllocate );

    HRESULT SetAllocateForStream( [in] WORD dwStreamNum,
                                  [in] BOOL fAllocate );
    HRESULT GetAllocateForStream( [in] WORD dwSreamNum,
                                  [out] BOOL *pfAllocate );

    //
    // Get statistics on demand
    //
    HRESULT GetStatistics( [in] WM_READER_STATISTICS *pStatistics );

    //
    // Set client side information used for logging
    //
    HRESULT SetClientInfo( [in] WM_READER_CLIENTINFO *pClientInfo );

    //
    // Get the maximum required buffer sizes that the SDK will allocate.
    // The first is for output buffers, the second for stream buffers.
    //
    HRESULT GetMaxOutputSampleSize( [in] DWORD dwOutput, [out] DWORD *pcbMax );
    HRESULT GetMaxStreamSampleSize( [in] WORD wStream, [out] DWORD *pcbMax );

    //
    // Used to notify the reader that it's delivering data
    // too slowly to the client.  The reader will try to speed
    // up.
    //
    HRESULT NotifyLateDelivery( [in] QWORD cnsLateness );
};


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BEB-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMReaderCallbackAdvanced Interface"),
    pointer_default(unique),
    local
]
//
// For some advanced functionality, the IWMReaderCallback must support this
// interface.
//
interface IWMReaderCallbackAdvanced : IUnknown
{
    //
    // Receive a sample directly from the ASF. To get this call, the user
    // must register himself to receive samples for a particular stream.
    //
    HRESULT OnStreamSample( [in] WORD wStreamNum,
                            [in] QWORD cnsSampleTime,
                            [in] QWORD cnsSampleDuration,
                            [in] DWORD dwFlags,
                            [in] INSSBuffer *pSample,
                            [in] void *pvContext );

    //
    // In some cases, the user may want to get callbacks telling what the
    // reader thinks the current time is. This is interesting in 2 cases:
    // - If the ASF has gaps in it; say no audio for 10 seconds. This call
    //   will continue to be called, while OnSample won't be called.
    // - If the user is driving the clock, the reader needs to communicate
    //   back to the user its time, to avoid the user overrunning the reader.
    //
    HRESULT OnTime( [in] QWORD cnsCurrentTime, [in] void *pvContext );

    //
    // The user can also get callbacks when stream selection occurs.
    //
    HRESULT OnStreamSelection( [in] WORD wStreamCount,
                               [in] WORD *pStreamNumbers,
                               [in] WMT_STREAM_SELECTION *pSelections,
                               [in] void *pvContext );


    //
    // Will be called if the user got an async result from their
    // call to SetOutputProps.  The next sample you receive for
    // this output will have these properties.  The contents of the
    // media type after calling SetOutputProps and before receiving
    // an OutputPropsChanged notification are undefined.
    //
    HRESULT OnOutputPropsChanged( [in] DWORD dwOutputNum,
                                  [in] WM_MEDIA_TYPE *pMediaType,
                                  [in] void *pvContext );

    //
    // If the user has registered to allocate buffers, this is where he must
    // do it.
    //
    HRESULT AllocateForStream( [in] WORD wStreamNum,
                               [in] DWORD cbBuffer,
                               [out] INSSBuffer **ppBuffer,
                               [in] void *pvContext );    
                               
    HRESULT AllocateForOutput( [in] DWORD dwOutputNum,
                               [in] DWORD cbBuffer,
                               [out] INSSBuffer **ppBuffer,
                               [in] void *pvContext );
};

///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 96406BED-2B2B-11d3-B36B-00C04F6108FF ),
    helpstring( "IWMReaderStreamClock Interface"),
    pointer_default(unique),
    local
]
//
// Used to configure the network.  This interface is implemented by
// the IWMReader object.
//
interface IWMReaderStreamClock : IUnknown
{
    //
    // Get the current value of the stream clock
    //
    HRESULT GetTime( [in] QWORD *pcnsNow );
 
    //
    // Set or kill a timer.  All timers are automatically
    // killed whenever you stop the Reader.  When a timer
    // expires, you'll receive a WMT_TIMER OnStatus callback
    // with hr == S_OK, pValue = TimerId and pvContext == pvParam.
    // 
    //
    HRESULT SetTimer( [in] QWORD cnsWhen, [in]void *pvParam, [out] DWORD *pdwTimerId );
    HRESULT KillTimer( [in] DWORD dwTimerId );
}


///////////////////////////////////////////////////////////////////////////////
[
    object,
    uuid( 6d7cdc71-9888-11d3-8edc-00c04f6109cf ),
    helpstring( "IWMIndexer Interface"),
    pointer_default(unique),
    local
]
interface IWMIndexer : IUnknown
{
    //
    // Start is an asynchronous call; it returns almost immediately and the user 
    // should wait for appropriate OnStatus calls to be sent to the callback.
    //
    HRESULT StartIndexing( [in] const WCHAR *pwszURL,
                           [in] IWMStatusCallback *pCallback,
                           [in] void *pvContext );
    HRESULT Cancel();
};

